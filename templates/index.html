<!doctype html>
<html>
    <head>
        <title>System Dashboard</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
            rel="stylesheet"
        />
        <!-- Chart.js library -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!-- Date adapter for time scales -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
        <style>
            /* Default (dark mode) variables */
            :root {
                --bg-color: #0a0a0a;
                --glass: rgba(18, 18, 18, 0.7);
                --primary: #2d5a4f;
                --text: #aaaaaa;
            }
            /* Light mode variables */
            body.light-mode {
                --bg-color: #f0f0f0;
                --glass: rgba(255, 255, 255, 0.8);
                --primary: #8bbabb;
                --text: #000000;
            }
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            body {
                font-family: "Inter", sans-serif;
                background: var(--bg-color);
                color: var(--text);
                min-height: 100vh;
                position: relative;
                overflow-x: hidden;
                transition:
                    background 0.3s,
                    color 0.3s;
            }
            .hexagons {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                overflow: hidden;
                z-index: -1;
            }
            .hexagon {
                position: absolute;
                background: var(--primary);
                clip-path: polygon(
                    50% 0%,
                    100% 25%,
                    100% 75%,
                    50% 100%,
                    0% 75%,
                    0% 25%
                );
                opacity: 0.1;
                animation: pulse 10s infinite;
            }
            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1);
                    opacity: 0.1;
                }
                50% {
                    transform: scale(1.2);
                    opacity: 0.15;
                }
            }
            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 2rem;
                position: relative;
                z-index: 1;
            }
            .grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 1.5rem;
                margin-bottom: 2rem;
            }
            .card {
                background: var(--glass);
                backdrop-filter: blur(10px);
                border-radius: 1rem;
                padding: 1.5rem;
                border: 1px solid rgba(255, 255, 255, 0.1);
                position: relative;
                transition:
                    background 0.3s,
                    border 0.3s,
                    transform 0.3s,
                    box-shadow 0.3s;
                cursor: pointer;
                overflow: hidden;
            }
            .card:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
            .card-title {
                font-size: 1rem;
                margin-bottom: 1rem;
                color: #7d7d7d;
            }
            .stat-container {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                padding: 10px;
            }
            /* Chart container with extra padding */
            .chart-container {
                position: relative;
                width: 100%;
                max-width: 300px;
                height: 200px;
                padding: 10px;
            }
            .chart-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 3rem;
                color: rgba(255, 255, 255, 0.2);
                pointer-events: none;
            }
            /* Legend for Memory and Disk basic charts */
            .color-labels {
                display: flex;
                flex-direction: column;
                justify-content: center;
                margin-right: 10px;
                min-width: 60px;
            }
            .color-label {
                display: flex;
                align-items: center;
                font-size: 0.8rem;
                margin-bottom: 4px;
            }
            .color-box {
                display: inline-block;
                width: 16px;
                height: 16px;
                margin-right: 5px;
                border-radius: 3px;
                border: 1px solid #000;
            }
            /* Memory legend: free (dark green), used (dark red), cached (dark blue) */
            .color-box.free {
                background-color: #1e8449;
            }
            .color-box.used {
                background-color: #922b21;
            }
            .color-box.cached {
                background-color: #21618c;
            }
            /* Disk legend: used (dark red), free (dark green) */
            .detail-view .graph-label {
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
                margin-bottom: 0.5rem;
            }
            .detail-view canvas {
                height: 200px !important;
                max-height: 200px;
                width: 100%;
            }
            table {
                color: var(--text);
                width: 100%;
            }
            table th,
            table td {
                padding: 0.5rem;
                text-align: left;
            }
            button.update-btn {
                background: var(--primary);
                color: var(--text);
                border: none;
                padding: 0.3rem 0.5rem;
                border-radius: 0.3rem;
                cursor: pointer;
            }
            .mode-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: var(--primary);
                color: var(--text);
                border: none;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                transition:
                    background 0.3s,
                    color 0.3s;
                z-index: 1000;
            }
            .docker-card {
                margin-top: 1.5rem;
            }
            .chart-row {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                margin-bottom: 1rem;
            }
            .chart-row canvas {
                flex: 1 1 calc(50% - 1rem);
                height: 400px !important;
            }
            #network-detail-view .chart-row canvas {
                height: 400px !important;
            }
            .detail-label {
                font-weight: 600;
                margin-bottom: 0.5rem;
                text-align: center;
            }
            /* Docker status indicator styles */
            .status-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                display: inline-block;
            }
            .status-green {
                background-color: #1e8449;
            }
            .status-yellow {
                background-color: #f1c40f;
            }
            .status-blue {
                background-color: #21618c;
            }
            .status-red {
                background-color: #c0392b;
            }
        </style>
    </head>
    <body>
        <div class="hexagons" id="hexagon-container">
            <!-- Hexagon elements will be generated by script -->
        </div>
        <div class="container">
            <div class="grid">
                <!-- CPU Card -->
                <div class="card">
                    <h2 class="card-title">CPU Usage</h2>
                    <div class="stat-container">
                        <div class="chart-container">
                            <canvas id="cpuChart"></canvas>
                            <div id="cpuOverlay" class="chart-overlay">0%</div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="cpu-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">24hr CPU Usage</div>
                        <canvas id="cpuDetailChart"></canvas>
                    </div>
                </div>
                <!-- Memory Card -->
                <div class="card">
                    <h2 class="card-title">Memory Usage</h2>
                    <div class="stat-container">
                        <div class="color-labels">
                            <div class="color-label">
                                <span class="color-box free"></span>Free (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box used"></span>Used (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box cached"></span>Cached (GB)
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="memoryChart"></canvas>
                            <div id="memoryOverlay" class="chart-overlay">
                                0
                            </div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="memory-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">24hr Memory Usage (GB)</div>
                        <canvas id="memoryDetailChart"></canvas>
                    </div>
                </div>
                <!-- Disk Card -->
                <div class="card">
                    <h2 class="card-title">Disk Usage</h2>
                    <div class="stat-container">
                        <div class="color-labels">
                            <!-- "Total" removed per request -->
                            <div class="color-label">
                                <span class="color-box used"></span>Used (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box free"></span>Free (GB)
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="diskChart"></canvas>
                            <div id="diskOverlay" class="chart-overlay">0</div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="disk-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">7-Day Disk Used (GB)</div>
                        <canvas id="diskHistoryChart"></canvas>
                    </div>
                </div>
            </div>
            <!-- Network Card -->
            <div class="card">
                <h2 class="card-title">Network Throughput</h2>
                <div class="stat-container">
                    <canvas id="networkChart"></canvas>
                </div>
                <div
                    class="detail-view"
                    id="network-detail-view"
                    style="display: none"
                >
                    <div class="detail-label">Input Throughput</div>
                    <div id="networkDetailInputCharts"></div>
                    <div class="detail-label" style="margin-top: 1rem">
                        Output Throughput
                    </div>
                    <div
                        id="networkDetailOutputCharts"
                        style="margin-top: 1rem"
                    ></div>
                </div>
            </div>
            <!-- Docker Containers Card -->
            <div class="card docker-card">
                <h2 class="card-title">Docker Containers</h2>
                <div class="docker-container">
                    <table class="docker-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Name</th>
                                <th>Uptime</th>
                                <th>Image</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="docker-data">
                            <!-- Docker data will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <button
            class="mode-toggle"
            id="modeToggle"
            title="Toggle light/dark mode"
        >
            ðŸ’¡
        </button>
        <script>
            // Function to trigger container update via POST.
            function updateContainer(containerName) {
                fetch(`/update/${containerName}`, { method: "POST" })
                    .then((response) => response.json())
                    .then((data) => {
                        alert(data.message);
                    })
                    .catch((err) => {
                        alert("Error updating container: " + err);
                    });
            }

            // Global variables for detailed network charts.
            let networkDetailInputCharts = [];
            let networkDetailOutputCharts = [];
            let lastDetailedNetworkUpdate = 0;

            function chunkArray(array, n) {
                let chunks = [];
                for (let i = 0; i < array.length; i += n) {
                    chunks.push(array.slice(i, i + n));
                }
                return chunks;
            }

            function randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

            function randomFloat(min, max) {
                return Math.random() * (max - min) + min;
            }

            function generateHexagons(count) {
                const container = document.getElementById("hexagon-container");
                for (let i = 0; i < count; i++) {
                    const hex = document.createElement("div");
                    hex.classList.add("hexagon");
                    const top = randomInt(0, 100);
                    const left = randomInt(0, 100);
                    const size = randomInt(80, 250);
                    const delay = randomFloat(0, 10).toFixed(1);
                    hex.style.top = top + "%";
                    hex.style.left = left + "%";
                    hex.style.width = size + "px";
                    hex.style.height = size + "px";
                    hex.style.animationDelay = delay + "s";
                    container.appendChild(hex);
                }
            }
            generateHexagons(40);

            document.querySelectorAll(".card").forEach((card) => {
                card.addEventListener("click", function (e) {
                    if (e.target.tagName.toLowerCase() === "button") return;
                    const detailView = this.querySelector(".detail-view");
                    if (detailView) {
                        detailView.style.display =
                            detailView.style.display === "none" ||
                            detailView.style.display === ""
                                ? "block"
                                : "none";
                    }
                });
            });

            // CPU Chart & Overlay (Basic View)
            const cpuCtx = document.getElementById("cpuChart").getContext("2d");
            const cpuChart = new Chart(cpuCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "CPU Usage",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.4)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            max: 100,
                            grid: { color: "rgba(255,255,255,0.1)" },
                        },
                        x: {
                            grid: { display: false },
                            ticks: { display: false },
                        },
                    },
                },
            });
            const cpuOverlay = document.getElementById("cpuOverlay");

            const cpuDetailCtx = document
                .getElementById("cpuDetailChart")
                .getContext("2d");
            const cpuDetailChart = new Chart(cpuDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "24hr CPU Usage (%)",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            max: 100,
                            grid: { color: "rgba(255,255,255,0.1)" },
                        },
                        x: { grid: { display: false } },
                    },
                },
            });

            // Memory Basic Chart â€“ 3 datasets: Free, Used, Cached (in GB)
            const memoryCtx = document
                .getElementById("memoryChart")
                .getContext("2d");
            const memoryBasicChart = new Chart(memoryCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#1e8449",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Cached",
                            data: [],
                            borderColor: "#21618c",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const memoryOverlay = document.getElementById("memoryOverlay");
            const memoryDetailCtx = document
                .getElementById("memoryDetailChart")
                .getContext("2d");
            const memoryDetailChart = new Chart(memoryDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "24hr Memory Usage (GB)",
                            data: [],
                            borderColor: "#21618c",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(33,97,140,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });

            // Disk Basic Chart â€“ 2 datasets: Used, Free (in GiB)
            const diskCtx = document
                .getElementById("diskChart")
                .getContext("2d");
            const diskBasicChart = new Chart(diskCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#1e8449",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const diskOverlay = document.getElementById("diskOverlay");
            const diskDetailCtx = document
                .getElementById("diskHistoryChart")
                .getContext("2d");
            const diskHistoryChart = new Chart(diskDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "7-Day Disk Used (GB)",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(146,43,33,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });

            // Network Aggregated Chart
            const networkCtx = document
                .getElementById("networkChart")
                .getContext("2d");
            const networkChart = new Chart(networkCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Input (MiB/s)",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.2)",
                            borderWidth: 2,
                        },
                        {
                            label: "Output (MiB/s)",
                            data: [],
                            borderColor: "#ff5555",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(255,85,85,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });

            // To reduce jump-to-top on updates, weâ€™ll store and restore scroll position
            // after re-creating the net detail charts.
            function updateDetailedNetworkCharts(inputDatasets, outputDatasets) {
                const scrollPos = window.scrollY;
                const inputContainer = document.getElementById("networkDetailInputCharts");
                const outputContainer = document.getElementById("networkDetailOutputCharts");

                // Clear existing detail charts:
                inputContainer.innerHTML = "";
                outputContainer.innerHTML = "";
                networkDetailInputCharts = [];
                networkDetailOutputCharts = [];

                const maxPerChart = 6;
                const inputChunks = chunkArray(inputDatasets, maxPerChart);
                const outputChunks = chunkArray(outputDatasets, maxPerChart);

                inputChunks.forEach((chunk) => {
                    const rowDiv = document.createElement("div");
                    rowDiv.classList.add("chart-row");
                    const canvas = document.createElement("canvas");
                    rowDiv.appendChild(canvas);
                    inputContainer.appendChild(rowDiv);
                    const chart = new Chart(canvas.getContext("2d"), {
                        type: "line",
                        data: { datasets: chunk },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" },
                                    },
                                    grid: { display: false },
                                },
                                y: { grid: { color: "rgba(255,255,255,0.1)" } },
                            },
                        },
                    });
                    networkDetailInputCharts.push(chart);
                });

                outputChunks.forEach((chunk) => {
                    const rowDiv = document.createElement("div");
                    rowDiv.classList.add("chart-row");
                    const canvas = document.createElement("canvas");
                    rowDiv.appendChild(canvas);
                    outputContainer.appendChild(rowDiv);
                    const chart = new Chart(canvas.getContext("2d"), {
                        type: "line",
                        data: { datasets: chunk },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" },
                                    },
                                    grid: { display: false },
                                },
                                y: { grid: { color: "rgba(255,255,255,0.1)" } },
                            },
                        },
                    });
                    networkDetailOutputCharts.push(chart);
                });

                // Restore scroll position to prevent jump to top
                setTimeout(() => window.scrollTo(0, scrollPos), 0);
            }

            function updateStats() {
                fetch("/stats")
                    .then((response) => response.json())
                    .then((data) => {
                        console.log("Received stats data:", data);
                        const system = data.system || {
                            cpu: 0,
                            memory: {
                                percent: 0,
                                total: 0,
                                used: 0,
                                free: 0,
                                cached: 0,
                            },
                            disk: { percent: 0 },
                            cpu_history: { usage: [] },
                            disk_details: { history: [] },
                        };
                        // CPU Basic
                        cpuOverlay.textContent = Math.round(system.cpu) + "%";
                        cpuChart.data.labels = system.cpu_history.usage.map(() => "");
                        cpuChart.data.datasets[0].data = system.cpu_history.usage;
                        cpuChart.update();

                        if (system.cpu_details && system.cpu_details.history24h) {
                            const cpuDetailLabels = system.cpu_details.history24h.map(entry => entry.time);
                            const cpuDetailData = system.cpu_details.history24h.map(entry => entry.usage);
                            cpuDetailChart.data.labels = cpuDetailLabels;
                            cpuDetailChart.data.datasets[0].data = cpuDetailData;
                            cpuDetailChart.update();
                        }

                        // Memory Basic â€“ in GB; set y-axis max to total memory.
                        if (system.memory_history) {
                            memoryBasicChart.data.labels = system.memory_history.time;
                            memoryBasicChart.data.datasets[0].data = system.memory_history.free;
                            memoryBasicChart.data.datasets[1].data = system.memory_history.used;
                            memoryBasicChart.data.datasets[2].data = system.memory_history.cached;
                            if (system.memory.total) {
                                memoryBasicChart.options.scales.y.max = system.memory.total;
                            }
                            memoryBasicChart.update();
                        }
                        memoryOverlay.textContent = system.memory.used.toFixed(2);

                        // Memory Extended (if visible)
                        const memDetailView = document.getElementById("memory-detail-view");
                        if (
                            memDetailView &&
                            memDetailView.style.display !== "none" &&
                            system.memory_details &&
                            system.memory_details.history24h
                        ) {
                            const memDetailLabels = system.memory_details.history24h.map(entry => entry.time);
                            const memDetailData = system.memory_details.history24h.map(entry => entry.usage);
                            memoryDetailChart.data.labels = memDetailLabels;
                            memoryDetailChart.data.datasets[0].data = memDetailData;
                            memoryDetailChart.update();
                        }

                        // Disk Basic â€“ in GiB; set y-axis max to total disk capacity.
                        if (system.disk_history_basic) {
                            diskBasicChart.data.labels = system.disk_history_basic.time;
                            diskBasicChart.data.datasets[0].data = system.disk_history_basic.used;
                            diskBasicChart.data.datasets[1].data = system.disk_history_basic.free;
                            if (system.disk.total) {
                                diskBasicChart.options.scales.y.max = system.disk.total;
                            }
                            diskBasicChart.update();
                        }
                        diskOverlay.textContent = system.disk.used.toFixed(2);

                        // Disk Extended (if visible)
                        const diskDetailView = document.getElementById("disk-detail-view");
                        if (
                            diskDetailView &&
                            diskDetailView.style.display !== "none" &&
                            system.disk_details &&
                            system.disk_details.history
                        ) {
                            const diskDetailLabels = system.disk_details.history.map(entry => entry.time);
                            const diskDetailData = system.disk_details.history.map(entry => entry.used);
                            diskHistoryChart.data.labels = diskDetailLabels;
                            diskHistoryChart.data.datasets[0].data = diskDetailData;
                            diskHistoryChart.update();
                        }

                        // Network Aggregated â€“ select interface with prefix "e" if available.
                        if (data.network && data.network.interfaces) {
                            const interfaces = data.network.interfaces;
                            let mainInterface = null;
                            Object.keys(interfaces).forEach((key) => {
                                if (/^e/.test(key)) {
                                    mainInterface = key;
                                }
                            });
                            if (!mainInterface) {
                                mainInterface = Object.keys(interfaces)[0] || null;
                            }
                            if (mainInterface && interfaces[mainInterface].length > 0) {
                                const ifaceData = interfaces[mainInterface];
                                const labels = ifaceData.map(entry => entry.time);
                                const inputData = ifaceData.map(entry => entry.input);
                                const outputData = ifaceData.map(entry => entry.output);
                                networkChart.data.labels = labels;
                                networkChart.data.datasets[0].data = inputData;
                                networkChart.data.datasets[1].data = outputData;
                                networkChart.update();
                            }
                        }

                        // Network Detailed (if visible)
                        const netDetailView = document.getElementById("network-detail-view");
                        if (
                            netDetailView &&
                            netDetailView.style.display !== "none" &&
                            data.network &&
                            data.network.interfaces
                        ) {
                            let now = Date.now();
                            if (now - lastDetailedNetworkUpdate > 5000) {
                                let detailedInterfaces = {};
                                for (let iface in data.network.interfaces) {
                                    if (/^(enp|ens|eth|tun|wg|vpn|docker|veth|br-)/.test(iface)) {
                                        detailedInterfaces[iface] = data.network.interfaces[iface];
                                    }
                                }
                                const colorPalette = [
                                    "rgba(255, 99, 132, 1)",
                                    "rgba(54, 162, 235, 1)",
                                    "rgba(255, 206, 86, 1)",
                                    "rgba(75, 192, 192, 1)",
                                    "rgba(153, 102, 255, 1)",
                                    "rgba(255, 159, 64, 1)",
                                ];
                                let inputDatasets = [];
                                let outputDatasets = [];
                                let dockerContainers = data.docker || [];
                                let dockerIndex = 0;

                                for (let iface in detailedInterfaces) {
                                    const ifaceData = detailedInterfaces[iface];
                                    let label = iface;

                                    // For interfaces starting with "veth", try to map them to a container name if possible:
                                    if (/^veth/.test(iface)) {
                                        if (dockerIndex < dockerContainers.length) {
                                            label = dockerContainers[dockerIndex].name;
                                            dockerIndex++;
                                        } else {
                                            continue; // Skip veth interfaces without a container name mapping.
                                        }
                                    } else if (/^br-/.test(iface)) {
                                        // For "br-" interfaces, assign a docker name if available but do not hide if not.
                                        if (dockerIndex < dockerContainers.length) {
                                            label = dockerContainers[dockerIndex].name;
                                            dockerIndex++;
                                        }
                                    }

                                    const inputPoints = ifaceData.map(e => ({ x: e.time, y: e.input }));
                                    const outputPoints = ifaceData.map(e => ({ x: e.time, y: e.output }));
                                    let color = colorPalette[inputDatasets.length % colorPalette.length];

                                    inputDatasets.push({
                                        label: label,
                                        data: inputPoints,
                                        borderColor: color,
                                        tension: 0.4,
                                        fill: false,
                                        borderWidth: 2,
                                    });
                                    outputDatasets.push({
                                        label: label,
                                        data: outputPoints,
                                        borderColor: color,
                                        tension: 0.4,
                                        fill: false,
                                        borderWidth: 2,
                                    });
                                }
                                updateDetailedNetworkCharts(inputDatasets, outputDatasets);
                                lastDetailedNetworkUpdate = now;
                            }
                        }

                        // Docker Containers Table â€“ Status indicator logic.
                        const dockerDataEl = document.getElementById("docker-data");
                        dockerDataEl.innerHTML = (data.docker || [])
                            .map((container) => {
                                let statusColorClass;
                                if (!container.up_to_date) {
                                    statusColorClass = "status-blue";
                                } else if (container.status.toLowerCase().includes("running")) {
                                    statusColorClass = "status-green";
                                } else if (
                                    container.status.toLowerCase().includes("starting") ||
                                    container.status.toLowerCase().includes("created")
                                ) {
                                    statusColorClass = "status-yellow";
                                } else {
                                    statusColorClass = "status-red";
                                }
                                return `<tr>
                                            <td><div class="status-indicator ${statusColorClass}"></div></td>
                                            <td>${container.name}</td>
                                            <td>${Math.floor(container.uptime / 3600)}h ${Math.floor((container.uptime % 3600) / 60)}m</td>
                                            <td>${container.image}</td>
                                            <td>${
                                                !container.up_to_date
                                                    ? `<button class="update-btn" onclick="updateContainer('${container.name}')">Update</button>`
                                                    : ""
                                            }</td>
                                        </tr>`;
                            })
                            .join("");
                    })
                    .catch((err) => console.error("Error fetching stats:", err));
            }

            setInterval(updateStats, 500);
            updateStats();

            const modeToggle = document.getElementById("modeToggle");
            modeToggle.addEventListener("click", () => {
                document.body.classList.toggle("light-mode");
            });
        </script>
    </body>
</html>

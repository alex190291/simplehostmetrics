<!doctype html>
<html>
    <head>
        <title>System Dashboard</title>
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap"
            rel="stylesheet"
        />
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
        <style>
            :root {
                --bg-color: #0a0a0a;
                --glass: rgba(18, 18, 18, 0.7);
                --primary: #2d5a4f;
                --text: #aaaaaa;
            }
            body.light-mode {
                --bg-color: #f0f0f0;
                --glass: rgba(255, 255, 255, 0.8);
                --primary: #8bbabb;
                --text: #000000;
            }
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            body {
                font-family: "Inter", sans-serif;
                background: var(--bg-color);
                color: var(--text);
                min-height: 100vh;
                position: relative;
                overflow-x: hidden;
                transition:
                    background 0.3s,
                    color 0.3s;
            }
            .hexagons {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                overflow: hidden;
                z-index: -1;
            }
            .hexagon {
                position: absolute;
                background: var(--primary);
                clip-path: polygon(
                    50% 0%,
                    100% 25%,
                    100% 75%,
                    50% 100%,
                    0% 75%,
                    0% 25%
                );
                opacity: 0.1;
                animation: pulse 10s infinite;
            }
            @keyframes pulse {
                0%,
                100% {
                    transform: scale(1);
                    opacity: 0.1;
                }
                50% {
                    transform: scale(1.2);
                    opacity: 0.15;
                }
            }
            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 2rem;
                position: relative;
                z-index: 1;
            }
            .grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 1.5rem;
                margin-bottom: 2rem;
            }
            .card {
                background: var(--glass);
                backdrop-filter: blur(10px);
                border-radius: 1rem;
                padding: 1.5rem;
                border: 1px solid rgba(255, 255, 255, 0.1);
                position: relative;
                transition:
                    background 0.3s,
                    border 0.3s,
                    transform 0.3s,
                    box-shadow 0.3s;
                cursor: pointer;
                overflow: hidden;
            }
            .card:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
            .card-header {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-bottom: 1rem;
            }
            .card-title {
                font-size: 1rem;
                color: #7d7d7d;
                margin-right: 0.5rem;
            }
            .stat-container {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                padding: 10px;
            }
            .chart-container {
                position: relative;
                width: 100%;
                max-width: 300px;
                height: 200px;
                padding: 10px;
            }
            .chart-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 3rem;
                color: rgba(255, 255, 255, 0.2);
                pointer-events: none;
            }
            .color-labels {
                display: flex;
                flex-direction: row;
                gap: 1rem;
            }
            .color-label {
                display: flex;
                align-items: center;
                font-size: 0.8rem;
            }
            .color-box {
                display: inline-block;
                width: 16px;
                height: 16px;
                margin-right: 5px;
                border-radius: 3px;
                border: 1px solid #000;
            }
            .color-box.free {
                background-color: #1e8449;
            }
            .color-box.usage {
                background-color: #057055;
            }
            .color-box.used {
                background-color: #922b21;
            }
            .color-box.cached {
                background-color: #21618c;
            }
            .detail-view .graph-label {
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
                margin-bottom: 0.5rem;
            }
            .detail-view canvas {
                height: 200px !important;
                max-height: 200px;
                width: 100%;
            }
            table {
                color: var(--text);
                width: 100%;
                border-collapse: collapse;
            }
            table th,
            table td {
                padding: 0.5rem;
                text-align: left;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            button.update-btn {
                background: var(--primary);
                color: var(--text);
                border: none;
                padding: 0.3rem 0.5rem;
                border-radius: 0.3rem;
                cursor: pointer;
                display: inline-flex;
                align-items: center;
                gap: 4px;
                transition: background-color 0.6s ease;
            }
            .spinner {
                display: inline-block;
                width: 16px;
                height: 16px;
                border: 2px solid rgba(255, 255, 255, 0.4);
                border-top: 2px solid rgba(255, 255, 255, 1);
                border-radius: 50%;
                animation: spin 0.6s linear infinite;
                margin-left: 4px;
            }
            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }
            .mode-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: var(--primary);
                color: var(--text);
                border: none;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                transition:
                    background 0.3s,
                    color 0.3s;
                z-index: 1000;
            }
            .docker-card {
                margin-top: 1.5rem;
            }
            .chart-row {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                margin-bottom: 1rem;
            }
            .chart-row canvas {
                flex: 1 1 calc(50% - 1rem);
                height: 400px !important;
            }
            #network-detail-view .chart-row canvas {
                height: 400px !important;
            }
            .detail-label {
                font-weight: 600;
                margin-bottom: 0.5rem;
                text-align: center;
            }
            .status-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                display: inline-block;
            }
            .status-green {
                background-color: #1e8449;
            }
            .status-yellow {
                background-color: #f1c40f;
            }
            .status-blue {
                background-color: #21618c;
            }
            .status-red {
                background-color: #c0392b;
            }
        </style>
    </head>
    <body>
        <div class="hexagons" id="hexagon-container"></div>
        <div class="container">
            <div class="grid">
                <!-- Memory -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">CPU</h2>
                        <div class="color-labels">
                            <div class="color-label">
                                <span class="color-box usage"></span>Usage
                            </div>
                        </div>
                    </div>
                    <div class="stat-container">
                        <div class="chart-container">
                            <canvas id="cpuChart"></canvas>
                            <div id="cpuOverlay" class="chart-overlay">0%</div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="cpu-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">24hr CPU Usage</div>
                        <canvas id="cpuDetailChart"></canvas>
                    </div>
                </div>

                <!-- Memory -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">RAM</h2>
                        <div class="color-labels">
                            <div class="color-label">
                                <span class="color-box free"></span>Free
                            </div>
                            <div class="color-label">
                                <span class="color-box used"></span>Used
                            </div>
                            <div class="color-label">
                                <span class="color-box cached"></span>Cached
                            </div>
                        </div>
                    </div>
                    <div class="stat-container">
                        <div class="chart-container">
                            <canvas id="memoryChart"></canvas>
                            <div id="memoryOverlay" class="chart-overlay">
                                0
                            </div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="memory-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">24hr RAM Usage</div>
                        <canvas id="memoryDetailChart"></canvas>
                    </div>
                </div>

                <!-- Disk -->
                <div class="card">
                    <div class="card-header">
                        <h2 class="card-title">Disk</h2>
                        <div class="color-labels">
                            <div class="color-label">
                                <span class="color-box used"></span>Used
                            </div>
                            <div class="color-label">
                                <span class="color-box free"></span>Free
                            </div>
                        </div>
                    </div>
                    <div class="stat-container">
                        <div class="chart-container">
                            <canvas id="diskChart"></canvas>
                            <div id="diskOverlay" class="chart-overlay">0</div>
                        </div>
                    </div>
                    <div
                        class="detail-view"
                        id="disk-detail-view"
                        style="display: none"
                    >
                        <div class="graph-label">7-Day Disk Used</div>
                        <canvas id="diskHistoryChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Network -->
            <div class="card">
                <h2 class="card-title">Network Throughput</h2>
                <div class="stat-container">
                    <canvas id="networkChart"></canvas>
                </div>
                <div
                    class="detail-view"
                    id="network-detail-view"
                    style="display: none"
                >
                    <div class="detail-label">Input Throughput</div>
                    <div id="networkDetailInputCharts"></div>
                    <div class="detail-label" style="margin-top: 1rem">
                        Output Throughput
                    </div>
                    <div
                        id="networkDetailOutputCharts"
                        style="margin-top: 1rem"
                    ></div>
                </div>
            </div>

            <!-- Docker -->
            <div class="card docker-card">
                <h2 class="card-title">Docker Containers</h2>
                <!-- "Check all updates" button -->
                <button
                    class="update-btn"
                    id="checkAllBtn"
                    style="margin-bottom: 1rem"
                    onclick="checkAllUpdates()"
                >
                    â†» Check for updates
                </button>
                <div class="docker-container">
                    <table class="docker-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Name</th>
                                <th>Uptime</th>
                                <th>Image</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="docker-data"></tbody>
                    </table>
                </div>
            </div>
        </div>
        <button
            class="mode-toggle"
            id="modeToggle"
            title="Toggle light/dark mode"
        >
            ðŸ’¡
        </button>
        <script>
            // Helper: set button background color
            function setButtonColor(button, color) {
                button.style.backgroundColor = color;
            }

            // Poll single-container update status
            function pollContainerUpdate(containerName, button) {
                const pollInt = setInterval(() => {
                    fetch(`/update_status/${containerName}`)
                        .then((r) => r.json())
                        .then((st) => {
                            if (st.in_progress && !st.error) {
                                if (!button.dataset.startedUpdate) {
                                    setButtonColor(button, "yellow");
                                    button.dataset.startedUpdate = "true";
                                }
                                button.innerHTML = `${st.phase} <div class="spinner"></div>`;
                                return;
                            }
                            clearInterval(pollInt);

                            if (st.error) {
                                setButtonColor(button, "red");
                                button.innerHTML = "Update failed";
                                button.disabled = false;
                            } else if (st.success) {
                                setButtonColor(button, "#33cc33");
                                button.innerHTML = "Updated successfully";
                                button.disabled = true;
                                setTimeout(() => {
                                    setButtonColor(button, "var(--primary)");
                                    button.style.display = "none";
                                    button.disabled = false;
                                }, 10000);
                            }
                            updateStats();
                        })
                        .catch((err) => {
                            console.error("Error polling update status:", err);
                            clearInterval(pollInt);
                        });
                }, 1000);
            }

            function updateContainer(containerName) {
                const btn = event.target;
                if (btn.innerHTML.toLowerCase().includes("failed")) {
                    setButtonColor(btn, "var(--primary)");
                }
                btn.innerHTML = `initializing... <div class="spinner"></div>`;
                btn.disabled = true;

                fetch(`/update/${containerName}`, { method: "POST" })
                    .then((r) => r.json())
                    .then(() => {
                        pollContainerUpdate(containerName, btn);
                    })
                    .catch((err) => {
                        console.error("Error updating container:", err);
                    });
            }

            let checkAllInterval = null;
            function checkAllUpdates() {
                const btn = document.getElementById("checkAllBtn");
                btn.disabled = true;
                btn.innerHTML = `â†» Check for updates <div class="spinner"></div>`;

                fetch("/check_all", { method: "POST" })
                    .then((r) => r.json())
                    .then((d) => {
                        if (d.status !== "already_in_progress") {
                            checkAllInterval = setInterval(
                                pollCheckAllStatus,
                                500,
                            );
                        } else {
                            btn.innerHTML = "â†» Check for updates";
                            btn.disabled = false;
                        }
                    })
                    .catch((err) => {
                        console.error("Error starting check_all:", err);
                        btn.disabled = false;
                        btn.innerHTML = "â†» Check for updates";
                    });
            }

            function pollCheckAllStatus() {
                const btn = document.getElementById("checkAllBtn");
                fetch("/check_all_status")
                    .then((r) => r.json())
                    .then((st) => {
                        if (st.in_progress) {
                            btn.innerHTML = `Checking... (${st.checked}/${st.total})`;
                        } else {
                            btn.innerHTML = "â†» Check for updates";
                            btn.disabled = false;
                            clearInterval(checkAllInterval);
                            checkAllInterval = null;
                            updateStats();
                        }
                    })
                    .catch((err) =>
                        console.error("Error polling check_all status:", err),
                    );
            }

            let networkDetailInputCharts = [];
            let networkDetailOutputCharts = [];
            let lastDetailedNetworkUpdate = 0;

            function chunkArray(arr, n) {
                let chunks = [];
                for (let i = 0; i < arr.length; i += n) {
                    chunks.push(arr.slice(i, i + n));
                }
                return chunks;
            }

            function randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            function randomFloat(min, max) {
                return Math.random() * (max - min) + min;
            }
            function generateHexagons(count) {
                const container = document.getElementById("hexagon-container");
                for (let i = 0; i < count; i++) {
                    const hex = document.createElement("div");
                    hex.classList.add("hexagon");
                    const top = randomInt(0, 100);
                    const left = randomInt(0, 100);
                    const size = randomInt(80, 250);
                    const delay = randomFloat(0, 10).toFixed(1);
                    hex.style.top = top + "%";
                    hex.style.left = left + "%";
                    hex.style.width = size + "px";
                    hex.style.height = size + "px";
                    hex.style.animationDelay = delay + "s";
                    container.appendChild(hex);
                }
            }
            generateHexagons(40);

            // Expand/collapse detail-views on card click (unless a button is clicked)
            document.querySelectorAll(".card").forEach((card) => {
                card.addEventListener("click", (e) => {
                    if (e.target.tagName.toLowerCase() === "button") return;
                    const detailView = card.querySelector(".detail-view");
                    if (detailView) {
                        detailView.style.display =
                            detailView.style.display === "" ||
                            detailView.style.display === "none"
                                ? "block"
                                : "none";
                    }
                });
            });

            // Shared X-axis config with small tick marks
            const sharedXAxisConfig = {
                grid: {
                    display: true,
                    drawTicks: true,
                    tickLength: 5,
                    color: "rgba(255,255,255,0.1)",
                },
                ticks: {
                    display: true,
                },
            };

            // CPU charts
            const cpuCtx = document.getElementById("cpuChart").getContext("2d");
            const cpuChart = new Chart(cpuCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "CPU",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.4)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: {
                            max: 100,
                            grid: { color: "rgba(255,255,255,0.1)" },
                        },
                    },
                },
            });
            const cpuOverlay = document.getElementById("cpuOverlay");

            const cpuDetailCtx = document
                .getElementById("cpuDetailChart")
                .getContext("2d");
            const cpuDetailChart = new Chart(cpuDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "24hr CPU Usage (%)",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: {
                            max: 100,
                            grid: { color: "rgba(255,255,255,0.1)" },
                        },
                    },
                },
            });

            // Memory charts
            const memCtx = document
                .getElementById("memoryChart")
                .getContext("2d");
            const memoryBasicChart = new Chart(memCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#1e8449",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Cached",
                            data: [],
                            borderColor: "#21618c",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                    },
                },
            });
            const memoryOverlay = document.getElementById("memoryOverlay");

            const memoryDetailCtx = document
                .getElementById("memoryDetailChart")
                .getContext("2d");
            const memoryDetailChart = new Chart(memoryDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "24hr RAM Usage",
                            data: [],
                            borderColor: "#21618c",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(33,97,140,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                    },
                },
            });

            // Disk charts
            const diskCtx = document
                .getElementById("diskChart")
                .getContext("2d");
            const diskBasicChart = new Chart(diskCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#1e8449",
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                    },
                },
            });
            const diskOverlay = document.getElementById("diskOverlay");

            const diskDetailCtx = document
                .getElementById("diskHistoryChart")
                .getContext("2d");
            const diskHistoryChart = new Chart(diskDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "7-Day Disk Used (GB)",
                            data: [],
                            borderColor: "#922b21",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(146,43,33,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                    },
                },
            });

            // Network
            const netCtx = document
                .getElementById("networkChart")
                .getContext("2d");
            const networkChart = new Chart(netCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Input (MiB/s)",
                            data: [],
                            borderColor: "rgba(5,112,85,1)",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(45,90,79,0.2)",
                            borderWidth: 2,
                        },
                        {
                            label: "Output (MiB/s)",
                            data: [],
                            borderColor: "#ff5555",
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(255,85,85,0.2)",
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: sharedXAxisConfig,
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                    },
                },
            });

            function updateDetailedNetworkCharts(
                inputDatasets,
                outputDatasets,
            ) {
                const scrollPos = window.scrollY;
                const inputContainer = document.getElementById(
                    "networkDetailInputCharts",
                );
                const outputContainer = document.getElementById(
                    "networkDetailOutputCharts",
                );
                inputContainer.innerHTML = "";
                outputContainer.innerHTML = "";
                networkDetailInputCharts = [];
                networkDetailOutputCharts = [];

                const maxPerChart = 6;
                const inChunks = chunkArray(inputDatasets, maxPerChart);
                const outChunks = chunkArray(outputDatasets, maxPerChart);

                inChunks.forEach((chunk) => {
                    const rowDiv = document.createElement("div");
                    rowDiv.classList.add("chart-row");
                    const canvas = document.createElement("canvas");
                    rowDiv.appendChild(canvas);
                    inputContainer.appendChild(rowDiv);

                    const chart = new Chart(canvas.getContext("2d"), {
                        type: "line",
                        data: { datasets: chunk },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" },
                                    },
                                    grid: {
                                        display: true,
                                        drawTicks: true,
                                        tickLength: 5,
                                        color: "rgba(255,255,255,0.1)",
                                    },
                                    ticks: {
                                        display: true,
                                    },
                                },
                                y: {
                                    grid: {
                                        color: "rgba(255,255,255,0.1)",
                                    },
                                },
                            },
                        },
                    });
                    networkDetailInputCharts.push(chart);
                });

                outChunks.forEach((chunk) => {
                    const rowDiv = document.createElement("div");
                    rowDiv.classList.add("chart-row");
                    const canvas = document.createElement("canvas");
                    rowDiv.appendChild(canvas);
                    outputContainer.appendChild(rowDiv);

                    const chart = new Chart(canvas.getContext("2d"), {
                        type: "line",
                        data: { datasets: chunk },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" },
                                    },
                                    grid: {
                                        display: true,
                                        drawTicks: true,
                                        tickLength: 5,
                                        color: "rgba(255,255,255,0.1)",
                                    },
                                    ticks: {
                                        display: true,
                                    },
                                },
                                y: {
                                    grid: {
                                        color: "rgba(255,255,255,0.1)",
                                    },
                                },
                            },
                        },
                    });
                    networkDetailOutputCharts.push(chart);
                });
                setTimeout(() => window.scrollTo(0, scrollPos), 0);
            }

            function updateStats() {
                fetch("/stats")
                    .then((r) => r.json())
                    .then((data) => {
                        const system = data.system || {};

                        // CPU
                        cpuOverlay.textContent =
                            Math.round(system.cpu || 0) + "%";
                        if (system.cpu_history && system.cpu_history.usage) {
                            cpuChart.data.labels = system.cpu_history.time;
                            cpuChart.data.datasets[0].data =
                                system.cpu_history.usage;
                            cpuChart.update();
                        }
                        if (
                            system.cpu_details &&
                            system.cpu_details.history24h
                        ) {
                            cpuDetailChart.data.labels =
                                system.cpu_details.history24h.map(
                                    (e) => e.time,
                                );
                            cpuDetailChart.data.datasets[0].data =
                                system.cpu_details.history24h.map(
                                    (e) => e.usage,
                                );
                            cpuDetailChart.update();
                        }

                        // Memory
                        if (system.memory_history) {
                            memoryBasicChart.data.labels =
                                system.memory_history.time;
                            memoryBasicChart.data.datasets[0].data =
                                system.memory_history.free;
                            memoryBasicChart.data.datasets[1].data =
                                system.memory_history.used;
                            memoryBasicChart.data.datasets[2].data =
                                system.memory_history.cached;
                            if (system.memory && system.memory.total) {
                                memoryBasicChart.options.scales.y.max =
                                    system.memory.total;
                            }
                            memoryBasicChart.update();
                        }
                        if (system.memory) {
                            memoryOverlay.textContent = (
                                system.memory.used || 0
                            ).toFixed(2);
                        }
                        const memDetailView =
                            document.getElementById("memory-detail-view");
                        if (
                            memDetailView &&
                            memDetailView.style.display !== "none" &&
                            system.memory_details &&
                            system.memory_details.history24h
                        ) {
                            memoryDetailChart.data.labels =
                                system.memory_details.history24h.map(
                                    (e) => e.time,
                                );
                            memoryDetailChart.data.datasets[0].data =
                                system.memory_details.history24h.map(
                                    (e) => e.usage,
                                );
                            memoryDetailChart.update();
                        }

                        // Disk
                        if (system.disk_history_basic) {
                            diskBasicChart.data.labels =
                                system.disk_history_basic.time;
                            diskBasicChart.data.datasets[0].data =
                                system.disk_history_basic.used;
                            diskBasicChart.data.datasets[1].data =
                                system.disk_history_basic.free;
                            if (system.disk && system.disk.total) {
                                diskBasicChart.options.scales.y.max =
                                    system.disk.total;
                            }
                            diskBasicChart.update();
                        }
                        if (system.disk) {
                            diskOverlay.textContent = (
                                system.disk.used || 0
                            ).toFixed(2);
                        }
                        const diskDetailView =
                            document.getElementById("disk-detail-view");
                        if (
                            diskDetailView &&
                            diskDetailView.style.display !== "none" &&
                            system.disk_details &&
                            system.disk_details.history
                        ) {
                            diskHistoryChart.data.labels =
                                system.disk_details.history.map((e) => e.time);
                            diskHistoryChart.data.datasets[0].data =
                                system.disk_details.history.map((e) => e.used);
                            diskHistoryChart.update();
                        }

                        // Network
                        if (data.network && data.network.interfaces) {
                            const interfaces = data.network.interfaces;
                            let mainInterface = null;
                            Object.keys(interfaces).forEach((k) => {
                                if (/^e/.test(k)) mainInterface = k;
                            });
                            if (!mainInterface) {
                                mainInterface =
                                    Object.keys(interfaces)[0] || null;
                            }
                            if (
                                mainInterface &&
                                interfaces[mainInterface].length > 0
                            ) {
                                const ifaceData = interfaces[mainInterface];
                                const labels = ifaceData.map((e) => e.time);
                                const inputData = ifaceData.map((e) => e.input);
                                const outputData = ifaceData.map(
                                    (e) => e.output,
                                );
                                networkChart.data.labels = labels;
                                networkChart.data.datasets[0].data = inputData;
                                networkChart.data.datasets[1].data = outputData;
                                networkChart.update();
                            }
                        }
                        const netDetailView = document.getElementById(
                            "network-detail-view",
                        );
                        if (
                            netDetailView &&
                            netDetailView.style.display !== "none" &&
                            data.network &&
                            data.network.interfaces
                        ) {
                            let now = Date.now();
                            if (now - lastDetailedNetworkUpdate > 5000) {
                                let detailedInterfaces = {};
                                for (let iface in data.network.interfaces) {
                                    if (
                                        /^(enp|ens|eth|tun|wg|vpn|docker|veth|br-)/.test(
                                            iface,
                                        )
                                    ) {
                                        detailedInterfaces[iface] =
                                            data.network.interfaces[iface];
                                    }
                                }
                                const colorPalette = [
                                    "rgba(255,99,132,1)",
                                    "rgba(54,162,235,1)",
                                    "rgba(255,206,86,1)",
                                    "rgba(75,192,192,1)",
                                    "rgba(153,102,255,1)",
                                    "rgba(255,159,64,1)",
                                ];
                                let inputDatasets = [];
                                let outputDatasets = [];
                                let dockerContainers = data.docker || [];
                                let dockerIndex = 0;

                                for (let iface in detailedInterfaces) {
                                    const arr = detailedInterfaces[iface];
                                    let label = iface;
                                    if (/^veth/.test(iface)) {
                                        if (
                                            dockerIndex <
                                            dockerContainers.length
                                        ) {
                                            label =
                                                dockerContainers[dockerIndex]
                                                    .name;
                                            dockerIndex++;
                                        }
                                    } else if (/^br-/.test(iface)) {
                                        if (
                                            dockerIndex <
                                            dockerContainers.length
                                        ) {
                                            label =
                                                dockerContainers[dockerIndex]
                                                    .name;
                                            dockerIndex++;
                                        }
                                    }
                                    const inputPts = arr.map((e) => ({
                                        x: e.time,
                                        y: e.input,
                                    }));
                                    const outputPts = arr.map((e) => ({
                                        x: e.time,
                                        y: e.output,
                                    }));
                                    let color =
                                        colorPalette[
                                            inputDatasets.length %
                                                colorPalette.length
                                        ];
                                    inputDatasets.push({
                                        label,
                                        data: inputPts,
                                        borderColor: color,
                                        tension: 0.4,
                                        fill: false,
                                        borderWidth: 2,
                                    });
                                    outputDatasets.push({
                                        label,
                                        data: outputPts,
                                        borderColor: color,
                                        tension: 0.4,
                                        fill: false,
                                        borderWidth: 2,
                                    });
                                }
                                updateDetailedNetworkCharts(
                                    inputDatasets,
                                    outputDatasets,
                                );
                                lastDetailedNetworkUpdate = now;
                            }
                        }

                        // Docker table
                        const dockerDataEl =
                            document.getElementById("docker-data");
                        dockerDataEl.innerHTML = (data.docker || [])
                            .map((cont) => {
                                let statusClass;
                                const lowerStatus = cont.status
                                    ? cont.status.toLowerCase()
                                    : "";

                                if (lowerStatus.includes("update success")) {
                                    statusClass = "status-green";
                                } else if (/^updat/i.test(lowerStatus)) {
                                    statusClass = "status-yellow";
                                    if (lowerStatus.includes("failed")) {
                                        statusClass = "status-red";
                                    }
                                } else if (!cont.up_to_date) {
                                    statusClass = "status-blue";
                                } else if (lowerStatus.includes("running")) {
                                    statusClass = "status-green";
                                } else if (
                                    lowerStatus.includes("starting") ||
                                    lowerStatus.includes("created")
                                ) {
                                    statusClass = "status-yellow";
                                } else {
                                    statusClass = "status-red";
                                }

                                const hrs = Math.floor(cont.uptime / 3600);
                                const mins = Math.floor(
                                    (cont.uptime % 3600) / 60,
                                );

                                let updateBtn = "";
                                if (
                                    !cont.up_to_date &&
                                    !/updating/i.test(cont.status)
                                ) {
                                    updateBtn = `<button class="update-btn" onclick="updateContainer('${cont.name}')">â†‘ Update</button>`;
                                }

                                return `<tr>
                                    <td><div class="status-indicator ${statusClass}"></div></td>
                                    <td>${cont.name}</td>
                                    <td>${hrs}h ${mins}m</td>
                                    <td>${cont.image}</td>
                                    <td>${updateBtn}</td>
                                </tr>`;
                            })
                            .join("");
                    })
                    .catch((err) =>
                        console.error("Error fetching stats:", err),
                    );
            }

            // 500ms front-end polling
            setInterval(updateStats, 500);
            updateStats();

            const modeToggle = document.getElementById("modeToggle");
            modeToggle.addEventListener("click", () => {
                document.body.classList.toggle("light-mode");
            });
        </script>
    </body>
</html>

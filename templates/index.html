<!doctype html>
<html>
    <head>
        <title>System Dashboard</title>
        <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet" />
        <!-- Chart.js library -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <!-- Date adapter for time scales -->
        <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
        <style>
            /* Default (dark mode) variables */
            :root {
                --bg-color: #0a0a0a;
                --glass: rgba(18, 18, 18, 0.7);
                --primary: #2d5a4f;
                --text: #aaaaaa;
            }
            /* Light mode variables */
            body.light-mode {
                --bg-color: #f0f0f0;
                --glass: rgba(255, 255, 255, 0.8);
                --primary: #8bbabb;
                --text: #000000;
            }
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }
            body {
                font-family: "Inter", sans-serif;
                background: var(--bg-color);
                color: var(--text);
                min-height: 100vh;
                position: relative;
                overflow-x: hidden;
                transition: background 0.3s, color 0.3s;
            }
            .hexagons {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                overflow: hidden;
                z-index: -1;
            }
            .hexagon {
                position: absolute;
                background: var(--primary);
                clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
                opacity: 0.1;
                animation: pulse 10s infinite;
            }
            @keyframes pulse {
                0%, 100% {
                    transform: scale(1);
                    opacity: 0.1;
                }
                50% {
                    transform: scale(1.2);
                    opacity: 0.15;
                }
            }
            .container {
                max-width: 1200px;
                margin: 0 auto;
                padding: 2rem;
                position: relative;
                z-index: 1;
            }
            .grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                gap: 1.5rem;
                margin-bottom: 2rem;
            }
            .card {
                background: var(--glass);
                backdrop-filter: blur(10px);
                border-radius: 1rem;
                padding: 1.5rem;
                border: 1px solid rgba(255, 255, 255, 0.1);
                position: relative;
                transition: background 0.3s, border 0.3s, transform 0.3s, box-shadow 0.3s;
                cursor: pointer;
                overflow: hidden;
            }
            .card:hover {
                transform: scale(1.02);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            }
            .card-title {
                font-size: 1rem;
                margin-bottom: 1rem;
                color: #7d7d7d;
            }
            .stat-container {
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                padding: 10px;
            }
            /* Chart container with extra padding */
            .chart-container {
                position: relative;
                width: 100%;
                max-width: 300px;
                height: 200px;
                padding: 10px;
            }
            .chart-overlay {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 3rem;
                color: rgba(255, 255, 255, 0.2);
                pointer-events: none;
            }
            /* Legend for Memory and Disk basic charts */
            .color-labels {
                display: flex;
                flex-direction: column;
                justify-content: center;
                margin-right: 10px;
                min-width: 60px;
            }
            .color-label {
                display: flex;
                align-items: center;
                font-size: 0.8rem;
                margin-bottom: 4px;
            }
            .color-box {
                display: inline-block;
                width: 16px;
                height: 16px;
                margin-right: 5px;
                border-radius: 3px;
                border: 1px solid #000;
            }
            /* Memory legend: free (dark green), used (dark red), cached (dark blue) */
            .color-box.free {
                background-color: #1e8449;
            }
            .color-box.used {
                background-color: #922b21;
            }
            .color-box.cached {
                background-color: #21618c;
            }
            /* Disk legend: used (dark red), free (dark green) */
            .detail-view .graph-label {
                font-size: 1rem;
                font-weight: 600;
                text-align: center;
                margin-bottom: 0.5rem;
            }
            .detail-view canvas {
                height: 200px !important;
                max-height: 200px;
                width: 100%;
            }
            table {
                color: var(--text);
                width: 100%;
            }
            table th,
            table td {
                padding: 0.5rem;
                text-align: left;
            }
            button.update-btn {
                background: var(--primary);
                color: var(--text);
                border: none;
                padding: 0.3rem 0.5rem;
                border-radius: 0.3rem;
                cursor: pointer;
            }
            .mode-toggle {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: var(--primary);
                color: var(--text);
                border: none;
                border-radius: 50%;
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
                cursor: pointer;
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
                transition: background 0.3s, color 0.3s;
                z-index: 1000;
            }
            .docker-card {
                margin-top: 1.5rem;
            }
            /* For netgr2 extended view, we now use single canvases for Input and Output */
            #network-detail-view .network-chart {
                width: 100%;
                height: 180px;
                padding: 10px;
            }
            .detail-label {
                font-weight: 600;
                margin-bottom: 0.5rem;
                text-align: center;
            }
            /* Docker status indicator styles */
            .status-indicator {
                width: 10px;
                height: 10px;
                border-radius: 50%;
                display: inline-block;
            }
            .status-green {
                background-color: #1e8449;
            }
            .status-yellow {
                background-color: #f1c40f;
            }
            .status-blue {
                background-color: #21618c;
            }
            .status-red {
                background-color: #c0392b;
            }
        </style>
    </head>
    <body>
        <div class="hexagons" id="hexagon-container">
            <!-- Hexagon elements will be generated by script -->
        </div>
        <div class="container">
            <div class="grid">
                <!-- CPU Card -->
                <div class="card">
                    <h2 class="card-title">CPU Usage</h2>
                    <div class="stat-container">
                        <div class="chart-container">
                            <canvas id="cpuChart"></canvas>
                            <div id="cpuOverlay" class="chart-overlay">0%</div>
                        </div>
                    </div>
                    <div class="detail-view" id="cpu-detail-view" style="display: none">
                        <div class="graph-label">24hr CPU Usage</div>
                        <canvas id="cpuDetailChart"></canvas>
                    </div>
                </div>
                <!-- Memory Card -->
                <div class="card">
                    <h2 class="card-title">Memory Usage</h2>
                    <div class="stat-container">
                        <div class="color-labels">
                            <div class="color-label">
                                <span class="color-box free"></span>Free (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box used"></span>Used (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box cached"></span>Cached (GB)
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="memoryChart"></canvas>
                            <div id="memoryOverlay" class="chart-overlay">0</div>
                        </div>
                    </div>
                    <div class="detail-view" id="memory-detail-view" style="display: none">
                        <div class="graph-label">24hr Memory Usage (GB)</div>
                        <canvas id="memoryDetailChart"></canvas>
                    </div>
                </div>
                <!-- Disk Card -->
                <div class="card">
                    <h2 class="card-title">Disk Usage</h2>
                    <div class="stat-container">
                        <div class="color-labels">
                            <!-- "Total" removed per request -->
                            <div class="color-label">
                                <span class="color-box used"></span>Used (GB)
                            </div>
                            <div class="color-label">
                                <span class="color-box free"></span>Free (GB)
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="diskChart"></canvas>
                            <div id="diskOverlay" class="chart-overlay">0</div>
                        </div>
                    </div>
                    <div class="detail-view" id="disk-detail-view" style="display: none">
                        <div class="graph-label">7-Day Disk Used (GB)</div>
                        <canvas id="diskHistoryChart"></canvas>
                    </div>
                </div>
            </div>
            <!-- Network Card -->
            <div class="card">
                <h2 class="card-title">Network Throughput</h2>
                <div class="stat-container">
                    <canvas id="networkChart"></canvas>
                </div>
                <div class="detail-view" id="network-detail-view" style="display: none">
                    <div class="detail-label">Input Throughput</div>
                    <!-- Single canvas for netgr2 input -->
                    <canvas id="networkDetailInputChart" class="network-chart"></canvas>
                    <div class="detail-label" style="margin-top: 1rem">Output Throughput</div>
                    <!-- Single canvas for netgr2 output -->
                    <canvas id="networkDetailOutputChart" class="network-chart"></canvas>
                </div>
            </div>
            <!-- Docker Containers Card -->
            <div class="card docker-card">
                <h2 class="card-title">Docker Containers</h2>
                <div class="docker-container">
                    <table class="docker-table">
                        <thead>
                            <tr>
                                <th>Status</th>
                                <th>Name</th>
                                <th>Uptime</th>
                                <th>Image</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="docker-data">
                            <!-- Docker data will be inserted here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <button class="mode-toggle" id="modeToggle" title="Toggle light/dark mode">ðŸ’¡</button>
        <script>
            // Function to trigger container update via POST.
            function updateContainer(containerName) {
                fetch(`/update/${containerName}`, { method: "POST" })
                    .then((response) => response.json())
                    .then((data) => {
                        alert(data.message);
                    })
                    .catch((err) => {
                        alert("Error updating container: " + err);
                    });
            }

            // Generate hexagons in background.
            function randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            function randomFloat(min, max) {
                return Math.random() * (max - min) + min;
            }
            function generateHexagons(count) {
                const container = document.getElementById("hexagon-container");
                for (let i = 0; i < count; i++) {
                    const hex = document.createElement("div");
                    hex.classList.add("hexagon");
                    const top = randomInt(0, 100);
                    const left = randomInt(0, 100);
                    const size = randomInt(80, 250);
                    const delay = randomFloat(0, 10).toFixed(1);
                    hex.style.top = top + "%";
                    hex.style.left = left + "%";
                    hex.style.width = size + "px";
                    hex.style.height = size + "px";
                    hex.style.animationDelay = delay + "s";
                    container.appendChild(hex);
                }
            }
            generateHexagons(40);

            document.querySelectorAll(".card").forEach((card) => {
                card.addEventListener("click", function (e) {
                    if (e.target.tagName.toLowerCase() === "button") return;
                    const detailView = this.querySelector(".detail-view");
                    if (detailView) {
                        detailView.style.display =
                            detailView.style.display === "none" || detailView.style.display === ""
                                ? "block"
                                : "none";
                    }
                });
            });

            // Create charts for the basic and extended views.
            // CPU Basic Chart (cpugr1) with increased saturation.
            const cpuCtx = document.getElementById("cpuChart").getContext("2d");
            const cpuChart = new Chart(cpuCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [{
                        label: "CPU Usage",
                        data: [],
                        borderColor: "rgba(31,122,102,1)",
                        tension: 0.4,
                        fill: true,
                        backgroundColor: "rgba(31,122,102,0.2)",
                        borderWidth: 2,
                    }],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { max: 100, grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false }, ticks: { display: false } },
                    },
                },
            });
            const cpuOverlay = document.getElementById("cpuOverlay");
            // CPU Extended Chart (cpugr2) with increased saturation.
            const cpuDetailCtx = document.getElementById("cpuDetailChart").getContext("2d");
            const cpuDetailChart = new Chart(cpuDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [{
                        label: "24hr CPU Usage (%)",
                        data: [],
                        borderColor: "rgba(31,122,102,1)",
                        tension: 0.4,
                        fill: true,
                        backgroundColor: "rgba(31,122,102,0.2)",
                        borderWidth: 2,
                    }],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { max: 100, grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const memoryCtx = document.getElementById("memoryChart").getContext("2d");
            const memoryBasicChart = new Chart(memoryCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#145a32", // darker green
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#7b241c", // darker red
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Cached",
                            data: [],
                            borderColor: "#1b4f72", // darker blue
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const memoryOverlay = document.getElementById("memoryOverlay");
            const memoryDetailCtx = document.getElementById("memoryDetailChart").getContext("2d");
            const memoryDetailChart = new Chart(memoryDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [{
                        label: "24hr Memory Usage (GB)",
                        data: [],
                        borderColor: "#1b4f72", // darker blue
                        tension: 0.4,
                        fill: true,
                        backgroundColor: "rgba(27,75,114,0.2)", // darker blue background
                        borderWidth: 2,
                    }],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const diskCtx = document.getElementById("diskChart").getContext("2d");
            const diskBasicChart = new Chart(diskCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Used",
                            data: [],
                            borderColor: "#7b241c", // darker red
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                        {
                            label: "Free",
                            data: [],
                            borderColor: "#145a32", // darker green
                            tension: 0.4,
                            fill: false,
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    layout: { padding: { left: 10, right: 10 } },
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const diskOverlay = document.getElementById("diskOverlay");
            const diskDetailCtx = document.getElementById("diskHistoryChart").getContext("2d");
            const diskHistoryChart = new Chart(diskDetailCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [{
                        label: "7-Day Disk Used (GB)",
                        data: [],
                        borderColor: "#7b241c", // darker red
                        tension: 0.4,
                        fill: true,
                        backgroundColor: "rgba(123,36,28,0.2)", // darker red background
                        borderWidth: 2,
                    }],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            const networkCtx = document.getElementById("networkChart").getContext("2d");
            const networkChart = new Chart(networkCtx, {
                type: "line",
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: "Input (MiB/s)",
                            data: [],
                            borderColor: "rgba(30,40,38,1)", // darker shade for input
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(30,40,38,0.2)", // darker background for input
                            borderWidth: 2,
                        },
                        {
                            label: "Output (MiB/s)",
                            data: [],
                            borderColor: "#7b241c", // darker red for output
                            tension: 0.4,
                            fill: true,
                            backgroundColor: "rgba(123,36,28,0.2)", // darker red background for output
                            borderWidth: 2,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { grid: { color: "rgba(255,255,255,0.1)" } },
                        x: { grid: { display: false } },
                    },
                },
            });
            // Global variables for the extended network charts.
            // We now use a single chart for input and a single chart for output.
            let networkDetailInputChart, networkDetailOutputChart;
            function updateNetworkExtended(data) {
                if (!(data.network && data.network.interfaces)) return;
                // Build list of interfaces that pass the filter.
                let detailedIfaces = [];
                for (let iface in data.network.interfaces) {
                    // Hide interfaces that start with "veth" if no docker container name is available.
                    if (/^veth/.test(iface)) {
                        // For simplicity, skip veth interfaces.
                        continue;
                    }
                    detailedIfaces.push(iface);
                }
                // Limit to at most 6 interfaces.
                detailedIfaces = detailedIfaces.slice(0, 6);
                // Build datasets for input and output using a dark color palette.
                const darkColorPalette = [
                    "rgba(123,36,28,1)",    // dark red
                    "rgba(21,101,192,1)",   // dark blue
                    "rgba(189,147,0,1)",    // dark gold
                    "rgba(20,110,110,1)",   // dark cyan
                    "rgba(85,26,139,1)",    // dark purple
                    "rgba(183,65,14,1)"     // dark orange
                ];
                let inputDatasets = [];
                let outputDatasets = [];
                detailedIfaces.forEach((iface, idx) => {
                    const ifaceData = data.network.interfaces[iface];
                    // Use the entire history (each entry has time, input, output)
                    let inputPoints = ifaceData.map(e => ({ x: e.time, y: e.input }));
                    let outputPoints = ifaceData.map(e => ({ x: e.time, y: e.output }));
                    inputDatasets.push({
                        label: iface,
                        data: inputPoints,
                        borderColor: darkColorPalette[idx % darkColorPalette.length],
                        tension: 0.4,
                        fill: false,
                        borderWidth: 2,
                    });
                    outputDatasets.push({
                        label: iface,
                        data: outputPoints,
                        borderColor: darkColorPalette[idx % darkColorPalette.length],
                        tension: 0.4,
                        fill: false,
                        borderWidth: 2,
                    });
                });
                // Use the labels from the first dataset (if exists)
                let labels = (inputDatasets.length > 0) ? inputDatasets[0].data.map(p => p.x) : [];
                // Update or create the input extended chart.
                if (networkDetailInputChart) {
                    networkDetailInputChart.data.datasets = inputDatasets;
                    networkDetailInputChart.data.labels = labels;
                    networkDetailInputChart.update();
                } else {
                    const ctxIn = document.getElementById("networkDetailInputChart").getContext("2d");
                    networkDetailInputChart = new Chart(ctxIn, {
                        type: "line",
                        data: {
                            labels: labels,
                            datasets: inputDatasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" }
                                    },
                                    grid: { display: false }
                                },
                                y: { grid: { color: "rgba(255,255,255,0.1)" } }
                            }
                        }
                    });
                }
                // Update or create the output extended chart.
                if (networkDetailOutputChart) {
                    networkDetailOutputChart.data.datasets = outputDatasets;
                    networkDetailOutputChart.data.labels = labels;
                    networkDetailOutputChart.update();
                } else {
                    const ctxOut = document.getElementById("networkDetailOutputChart").getContext("2d");
                    networkDetailOutputChart = new Chart(ctxOut, {
                        type: "line",
                        data: {
                            labels: labels,
                            datasets: outputDatasets
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: true } },
                            scales: {
                                x: {
                                    type: "time",
                                    time: {
                                        parser: "HH:mm:ss",
                                        tooltipFormat: "HH:mm:ss",
                                        unit: "second",
                                        displayFormats: { second: "HH:mm:ss" }
                                    },
                                    grid: { display: false }
                                },
                                y: { grid: { color: "rgba(255,255,255,0.1)" } }
                            }
                        }
                    });
                }
            }
            // Update stats periodically.
            function updateStats() {
                fetch("/stats")
                    .then((response) => response.json())
                    .then((data) => {
                        console.log("Received stats data:", data);
                        const system = data.system || {
                            cpu: 0,
                            memory: { percent: 0, total: 0, used: 0, free: 0, cached: 0 },
                            disk: { percent: 0 },
                            cpu_history: { usage: [] },
                            disk_details: { history: [] },
                        };
                        // CPU Basic
                        cpuOverlay.textContent = Math.round(system.cpu) + "%";
                        cpuChart.data.labels = system.cpu_history.usage.map(() => "");
                        cpuChart.data.datasets[0].data = system.cpu_history.usage;
                        cpuChart.update();
                        if (system.cpu_details && system.cpu_details.history24h) {
                            const cpuDetailLabels = system.cpu_details.history24h.map(entry => entry.time);
                            const cpuDetailData = system.cpu_details.history24h.map(entry => entry.usage);
                            cpuDetailChart.data.labels = cpuDetailLabels;
                            cpuDetailChart.data.datasets[0].data = cpuDetailData;
                            cpuDetailChart.update();
                        }
                        // Memory Basic
                        if (system.memory_history) {
                            memoryBasicChart.data.labels = system.memory_history.time;
                            memoryBasicChart.data.datasets[0].data = system.memory_history.free;
                            memoryBasicChart.data.datasets[1].data = system.memory_history.used;
                            memoryBasicChart.data.datasets[2].data = system.memory_history.cached;
                            if (system.memory.total) {
                                memoryBasicChart.options.scales.y.max = system.memory.total;
                            }
                            memoryBasicChart.update();
                        }
                        memoryOverlay.textContent = system.memory.used.toFixed(2);
                        // Memory Extended
                        const memDetailView = document.getElementById("memory-detail-view");
                        if (memDetailView && memDetailView.style.display !== "none" &&
                            system.memory_details && system.memory_details.history24h) {
                            const memDetailLabels = system.memory_details.history24h.map(entry => entry.time);
                            const memDetailData = system.memory_details.history24h.map(entry => entry.usage);
                            memoryDetailChart.data.labels = memDetailLabels;
                            memoryDetailChart.data.datasets[0].data = memDetailData;
                            memoryDetailChart.update();
                        }
                        // Disk Basic
                        if (system.disk_history_basic) {
                            diskBasicChart.data.labels = system.disk_history_basic.time;
                            diskBasicChart.data.datasets[0].data = system.disk_history_basic.used;
                            diskBasicChart.data.datasets[1].data = system.disk_history_basic.free;
                            if (system.disk.total) {
                                diskBasicChart.options.scales.y.max = system.disk.total;
                            }
                            diskBasicChart.update();
                        }
                        diskOverlay.textContent = system.disk.used.toFixed(2);
                        // Disk Extended
                        const diskDetailView = document.getElementById("disk-detail-view");
                        if (diskDetailView && diskDetailView.style.display !== "none" &&
                            system.disk_details && system.disk_details.history) {
                            const diskDetailLabels = system.disk_details.history.map(entry => entry.time);
                            const diskDetailData = system.disk_details.history.map(entry => entry.used);
                            diskHistoryChart.data.labels = diskDetailLabels;
                            diskHistoryChart.data.datasets[0].data = diskDetailData;
                            diskHistoryChart.update();
                        }
                        // Network Aggregated
                        if (data.network && data.network.interfaces) {
                            const interfaces = data.network.interfaces;
                            let mainInterface = null;
                            Object.keys(interfaces).forEach((key) => {
                                if (/^enp/.test(key)) {
                                    mainInterface = key;
                                }
                            });
                            if (!mainInterface) {
                                mainInterface = Object.keys(interfaces)[0] || null;
                            }
                            if (mainInterface && interfaces[mainInterface].length > 0) {
                                const ifaceData = interfaces[mainInterface];
                                const labels = ifaceData.map(entry => entry.time);
                                const inputData = ifaceData.map(entry => entry.input);
                                const outputData = ifaceData.map(entry => entry.output);
                                networkChart.data.labels = labels;
                                networkChart.data.datasets[0].data = inputData;
                                networkChart.data.datasets[1].data = outputData;
                                networkChart.update();
                            }
                        }
                        // Network Extended (netgr2)
                        const netDetailView = document.getElementById("network-detail-view");
                        if (netDetailView && netDetailView.style.display !== "none") {
                            updateNetworkExtended(data);
                        }
                        // Docker Containers Table
                        const dockerDataEl = document.getElementById("docker-data");
                        dockerDataEl.innerHTML = (data.docker || [])
                            .map((container) => {
                                let statusColorClass;
                                if (!container.up_to_date) {
                                    statusColorClass = "status-blue";
                                } else if (container.status.toLowerCase().includes("running")) {
                                    statusColorClass = "status-green";
                                } else if (container.status.toLowerCase().includes("starting") ||
                                           container.status.toLowerCase().includes("created")) {
                                    statusColorClass = "status-yellow";
                                } else {
                                    statusColorClass = "status-red";
                                }
                                return `<tr>
                                            <td><div class="status-indicator ${statusColorClass}"></div></td>
                                            <td>${container.name}</td>
                                            <td>${Math.floor(container.uptime / 3600)}h ${Math.floor((container.uptime % 3600) / 60)}m</td>
                                            <td>${container.image}</td>
                                            <td>${!container.up_to_date ? `<button class="update-btn" onclick="updateContainer('${container.name}')">Update</button>` : ""}</td>
                                        </tr>`;
                            })
                            .join("");
                    })
                    .catch((err) => console.error("Error fetching stats:", err));
            }
            setInterval(updateStats, 500);
            updateStats();
            const modeToggle = document.getElementById("modeToggle");
            modeToggle.addEventListener("click", () => {
                document.body.classList.toggle("light-mode");
            });
        </script>
    </body>
</html>
